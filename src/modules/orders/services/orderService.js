const orderRepository = require('../repositories/orderRepository');const notificationService = require('./notificationService');const { ValidationError } = require('sequelize');class OrderService {  async obtenerTodos(filtros = {}) {    const pedidos = await orderRepository.findAll(filtros);    return pedidos.map(p => p.toJSON());  }  async obtenerPorId(id) {    if (!id || isNaN(id)) {      throw new Error('ID de pedido inválido');    }    const pedido = await orderRepository.findById(id);    if (!pedido) {      throw new Error('Pedido no encontrado');    }    return pedido.toJSON();  }  async obtenerPorNumeroPedido(numeroPedido) {    if (!numeroPedido) {      throw new Error('Número de pedido es requerido');    }    const pedido = await orderRepository.findByNumeroPedido(numeroPedido);    if (!pedido) {      throw new Error('Pedido no encontrado');    }    return pedido.toJSON();  }  async crear(datos, enviarNotificacion = true) {    const { fecha, hora, clienteNombre, whatsapp, direccion, productos, total, metodoPago, notas } = datos;    if (!clienteNombre) {      throw new Error('El nombre del cliente es requerido');    }    if (!whatsapp) {      throw new Error('El número de WhatsApp es requerido');    }    if (!productos || !Array.isArray(productos) || productos.length === 0) {      throw new Error('Debe incluir al menos un producto');    }    if (total === undefined || total === null) {      throw new Error('El total es requerido');    }    if (total < 0) {      throw new Error('El total no puede ser negativo');    }    productos.forEach((producto, index) => {      if (!producto.nombre && !producto.producto) {        throw new Error(`El producto ${index + 1} debe tener un nombre`);      }    });    const datosPedido = {      fecha: fecha || new Date().toISOString().split('T')[0],      hora: hora || null,      clienteNombre,      whatsapp: this.formatearWhatsApp(whatsapp),      direccion: direccion || null,      productos,      total: parseFloat(total),      metodoPago: metodoPago || null,      notas: notas || null,      estado: 'pendiente',      notificado: false,      activo: true    };    try {      const pedido = await orderRepository.create(datosPedido);      const pedidoJSON = pedido.toJSON();      if (enviarNotificacion) {        const notificado = await notificationService.enviarNotificacionPedido(pedidoJSON);        if (notificado) {          await orderRepository.update(pedido.id, {            notificado: true,            fechaNotificacion: new Date()          });          pedidoJSON.notificado = true;          pedidoJSON.fechaNotificacion = new Date();        }      }      return pedidoJSON;    } catch (error) {      this.manejarError(error);    }  }  async actualizar(id, datos) {    if (!id || isNaN(id)) {      throw new Error('ID de pedido inválido');    }    const { estado, productos, total, metodoPago, notas, direccion } = datos;    if (estado && !['pendiente', 'confirmado', 'en_preparacion', 'listo', 'en_camino', 'entregado', 'cancelado'].includes(estado)) {      throw new Error('Estado de pedido inválido');    }    if (total !== undefined && total < 0) {      throw new Error('El total no puede ser negativo');    }    const datosActualizar = {};    if (estado !== undefined) datosActualizar.estado = estado;    if (productos !== undefined) datosActualizar.productos = productos;    if (total !== undefined) datosActualizar.total = parseFloat(total);    if (metodoPago !== undefined) datosActualizar.metodoPago = metodoPago;    if (notas !== undefined) datosActualizar.notas = notas;    if (direccion !== undefined) datosActualizar.direccion = direccion;    try {      const pedido = await orderRepository.update(id, datosActualizar);      return pedido.toJSON();    } catch (error) {      if (error.message === 'Pedido no encontrado') {        throw error;      }      this.manejarError(error);    }  }  async actualizarEstado(id, estado) {    return await this.actualizar(id, { estado });  }  async eliminar(id) {    if (!id || isNaN(id)) {      throw new Error('ID de pedido inválido');    }    try {      await orderRepository.delete(id);      return true;    } catch (error) {      if (error.message === 'Pedido no encontrado') {        throw error;      }      throw new Error('Error al eliminar el pedido');    }  }  async obtenerPendientesNotificacion() {    const pedidos = await orderRepository.findPendientesNotificacion();    return pedidos.map(p => p.toJSON());  }  async reenviarNotificacion(id) {    const pedido = await this.obtenerPorId(id);    const notificado = await notificationService.enviarNotificacionPedido(pedido);    if (notificado) {      await orderRepository.update(id, {        notificado: true,        fechaNotificacion: new Date()      });    }    return notificado;  }  async obtenerEstadisticas(fechaDesde, fechaHasta) {    const estadisticas = await orderRepository.obtenerEstadisticas(fechaDesde, fechaHasta);    return {      totalPedidos: parseInt(estadisticas.totalPedidos) || 0,      totalVentas: parseFloat(estadisticas.totalVentas) || 0,      pendientes: parseInt(estadisticas.pendientes) || 0,      entregados: parseInt(estadisticas.entregados) || 0,      cancelados: parseInt(estadisticas.cancelados) || 0    };  }  formatearWhatsApp(numero) {    let formateado = numero.replace(/[\s\-\(\)]/g, '');    if (!formateado.startsWith('52') && formateado.length === 10) {      formateado = '52' + formateado;    }    return formateado;  }  manejarError(error) {    if (error instanceof ValidationError) {      const mensajes = error.errors.map(err => err.message).join(', ');      throw new Error(`Error de validación: ${mensajes}`);    }    throw error;  }}module.exports = new OrderService();