const productionRepository = require('../repositories/productionRepository');const { ValidationError } = require('sequelize');class ProductionService {  async obtenerTodos(filtros = {}) {    const registros = await productionRepository.findAll(filtros);    return registros.map(r => r.toJSON());  }  async obtenerPorId(id) {    if (!id || isNaN(id)) {      throw new Error('ID de registro inválido');    }    const registro = await productionRepository.findById(id);    if (!registro) {      throw new Error('Registro de producción no encontrado');    }    return registro.toJSON();  }  async obtenerPorFecha(fecha) {    if (!fecha) {      throw new Error('La fecha es requerida');    }    const registro = await productionRepository.findByFecha(fecha);    return registro ? registro.toJSON() : null;  }  async crear(datos) {    const { produccion_kg, total, devolucion, id_cliente } = datos;    if (!id_cliente) {      throw new Error('El cliente es requerido');    }    if (produccion_kg !== undefined && produccion_kg < 0) {      throw new Error('La producción en kg no puede ser negativa');    }    if (total !== undefined && total < 0) {      throw new Error('El total no puede ser negativo');    }    if (devolucion !== undefined && devolucion < 0) {      throw new Error('La devolución no puede ser negativa');    }    const fechaHoy = new Date().toISOString().split('T')[0];    const datosRegistro = {      produccion_kg: produccion_kg !== undefined ? parseFloat(produccion_kg) : null,      total: total !== undefined ? parseFloat(total) : null,      devolucion: devolucion !== undefined ? parseFloat(devolucion) : null,      id_cliente: parseInt(id_cliente),      fecha: fechaHoy    };    try {      const registro = await productionRepository.create(datosRegistro);      return registro.toJSON();    } catch (error) {      this.manejarError(error);    }  }  async actualizar(id, datos) {    if (!id || isNaN(id)) {      throw new Error('ID de registro inválido');    }    const { produccion_kg, total, devolucion, id_cliente } = datos;    if (produccion_kg !== undefined && produccion_kg < 0) {      throw new Error('La producción en kg no puede ser negativa');    }    if (total !== undefined && total < 0) {      throw new Error('El total no puede ser negativo');    }    if (devolucion !== undefined && devolucion < 0) {      throw new Error('La devolución no puede ser negativa');    }    const datosActualizar = {};    if (produccion_kg !== undefined) datosActualizar.produccion_kg = parseFloat(produccion_kg);    if (total !== undefined) datosActualizar.total = parseFloat(total);    if (devolucion !== undefined) datosActualizar.devolucion = parseFloat(devolucion);    if (id_cliente !== undefined) datosActualizar.id_cliente = parseInt(id_cliente);    try {      const registro = await productionRepository.update(id, datosActualizar);      return registro.toJSON();    } catch (error) {      if (error.message === 'Registro de producción no encontrado') {        throw error;      }      this.manejarError(error);    }  }  async eliminar(id) {    if (!id || isNaN(id)) {      throw new Error('ID de registro inválido');    }    try {      await productionRepository.delete(id);      return true;    } catch (error) {      if (error.message === 'Registro de producción no encontrado') {        throw error;      }      throw new Error('Error al eliminar el registro');    }  }  async obtenerEstadisticas(fechaDesde, fechaHasta) {    const estadisticas = await productionRepository.obtenerEstadisticas(fechaDesde, fechaHasta);    return {      totalCharolasCuartoKilo: parseInt(estadisticas.totalCuartos) || 0,      totalCharolasMedioKilo: parseInt(estadisticas.totalMedios) || 0,      totalDomosUnKilo: parseInt(estadisticas.totalUnKilo) || 0,      totalKilos: parseFloat(estadisticas.totalKilos) || 0    };  }  manejarError(error) {    if (error instanceof ValidationError) {      const mensajes = error.errors.map(err => err.message).join(', ');      throw new Error(`Error de validación: ${mensajes}`);    }    throw error;  }}module.exports = new ProductionService();