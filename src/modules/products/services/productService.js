const productRepository = require('../repositories/productRepository');const { ValidationError, UniqueConstraintError } = require('sequelize');const fs = require('fs');const path = require('path');class ProductService {  async obtenerTodos(filtros = {}) {    const productos = await productRepository.findAll(filtros);    return productos.map(p => p.toJSON());  }  async obtenerPorId(id) {    if (!id || isNaN(id)) {      throw new Error('ID de producto inv치lido');    }    const producto = await productRepository.findById(id);    if (!producto) {      throw new Error('Producto no encontrado');    }    return producto.toJSON();  }  async crear(datos, fotoPath = null) {    const { descripcion, precio, unidad_medida } = datos;    if (!precio) {      throw new Error('El precio es requerido');    }    if (precio < 0) {      throw new Error('El precio no puede ser negativo');    }    const datosProducto = {      descripcion: descripcion || null,      precio: parseFloat(precio),      unidad_medida: unidad_medida || null    };    if (fotoPath) {      datosProducto.imagen = fotoPath;    }    try {      const producto = await productRepository.create(datosProducto);      return producto.toJSON();    } catch (error) {      this.manejarError(error);    }  }  async actualizar(id, datos, fotoPath = null) {    if (!id || isNaN(id)) {      throw new Error('ID de producto inv치lido');    }    const { descripcion, precio, unidad_medida } = datos;    if (precio !== undefined && precio < 0) {      throw new Error('El precio no puede ser negativo');    }    const datosActualizar = {};    if (descripcion !== undefined) datosActualizar.descripcion = descripcion;    if (precio !== undefined) datosActualizar.precio = parseFloat(precio);    if (unidad_medida !== undefined) datosActualizar.unidad_medida = unidad_medida;    if (fotoPath) {      const productoActual = await productRepository.findById(id);      if (productoActual && productoActual.imagen) {        this.eliminarFoto(productoActual.imagen);      }      datosActualizar.imagen = fotoPath;    }    try {      const producto = await productRepository.update(id, datosActualizar);      return producto.toJSON();    } catch (error) {      if (error.message === 'Producto no encontrado') {        throw error;      }      this.manejarError(error);    }  }  async eliminar(id) {    if (!id || isNaN(id)) {      throw new Error('ID de producto inv치lido');    }    try {      await productRepository.delete(id);      return true;    } catch (error) {      if (error.message === 'Producto no encontrado') {        throw error;      }      throw new Error('Error al eliminar el producto');    }  }  eliminarFoto(fotoPath) {    if (!fotoPath) return;    try {      if (fotoPath.startsWith('/uploads') || fotoPath.startsWith('uploads')) {        const rutaCompleta = path.join(__dirname, '../../../', fotoPath);        if (fs.existsSync(rutaCompleta)) {          fs.unlinkSync(rutaCompleta);        }      }    } catch (error) {      console.error('Error al eliminar imagen:', error);    }  }  manejarError(error) {    if (error instanceof ValidationError) {      const mensajes = error.errors.map(err => err.message).join(', ');      throw new Error(`Error de validaci칩n: ${mensajes}`);    }    if (error instanceof UniqueConstraintError) {      throw new Error('Ya existe un producto con estos datos');    }    throw error;  }}module.exports = new ProductService();